//
//  Assertions.swift
//  EssentiaTests
//
//  Created by Jason Cardwell on 11/7/17.
//  Copyright © 2017 Moondeer Studios. All rights reserved.
//
import Foundation
import XCTest
import _SwiftXCTestOverlayShims
import Accelerate

/// Gemerates a description of an array suitable for inclusion in a failure message.
///
/// - Parameter values: The array of values.
/// - Returns: An appropriate description of `values`.
private func description<T>(of values: [T]) -> String {

  guard values.count > 20 else { return values.description }

  let prefix = values[...10].map({"\($0)"}).joined(separator: ", ")
  let suffix = values[(values.count - 10)...].map({"\($0)"}).joined(separator: ", ")
  return "[\(prefix) ... \(suffix)]"

}

/// Gemerates a description of a two dimensional array suitable for inclusion in a failure message.
///
/// - Parameter values: The two dimensional array of values.
/// - Returns: An appropriate description of `values`.
private func description<T>(of values: [[T]]) -> String {

  guard values.count > 20 else { return values.description }

  let prefix = values[...10].map({"\(description(of: $0))"}).joined(separator: ", ")
  let suffix = values[(values.count - 10)...].map({"\(description(of: $0))"}).joined(separator: ", ")
  return "[\(prefix) ... \(suffix)]"

}

/// Gemerates a description of a three dimensional array suitable for inclusion in a failure message.
///
/// - Parameter values: The three dimensional array of values.
/// - Returns: An appropriate description of `values`.
private func description<T>(of values: [[[T]]]) -> String {

  guard values.count > 20 else { return values.description }

  let prefix = values[...10].map({"\($0)"}).joined(separator: ", ")
  let suffix = values[(values.count - 10)...].map({"\($0)"}).joined(separator: ", ")
  return "[\(prefix) ... \(suffix)]"

}

/// Determines whether a value is equal to an expected value.
///
/// - Parameters:
///   - actual: The value to test.
///   - expected: The expected value.
///   - deviation: The allowable deviation between values.
/// - Returns: Whether `actual` is equal to `expected`.
private func equal<T:FloatingPoint>(_ actual: T, _ expected: T, deviation: T) -> Bool {
  guard !(actual.isNaN || expected.isNaN) else { return false }
  let diff: T
  if expected == 0 { diff = abs(actual) }
  else if actual == 0 { diff = abs(expected) }
  else { diff = abs((actual - expected) / abs (expected)) }
  return diff <= deviation
}

/// Calculates the mean for an array of floating point values.
///
/// - Parameter array: The array for which the mean will be calculated.
/// - Returns: The mean for `array`.
private func mean<T:FloatingPoint>(_ array: [T]) -> T {
  if let array = array as? [Float] {
    var result: Float = 0
    vDSP_meanv(array, 1, &result, vDSP_Length(array.count))
    return result as! T
  } else if let array = array as? [Double] {
    var result: Double = 0
    vDSP_meanvD(array, 1, &result, vDSP_Length(array.count))
    return result as! T
  } else {
    return array.reduce(0, +) / T(array.count)
  }
}

/// Calculates the mean of the difference between two arrays of floating point values.
///
/// - Parameters:
///   - array1: The first array of floating point values.
///   - array2: The second array of floating point values.
/// - Returns: The mean of the array generated by subtracting elements in `array2` from `array1`.
private func differenceMean<T:FloatingPoint>(_ array1: [T], _ array2: [T]) -> T {

  guard array1.count == array2.count else {
    fatalError("Expected array1 and array2 to have the same number of elements.")
  }

  if let array1 = array1 as? [Float], let array2 = array2 as? [Float] {

    var difference = Array<Float>(repeating: 0, count: array1.count)
    vDSP_vsub(array2, 1, array1, 1, &difference, 1, vDSP_Length(array1.count))
    vDSP_vabs(difference, 1, &difference, 1, vDSP_Length(difference.count))

    return mean(difference as! [T])

  } else if let array1 = array1 as? [Double], let array2 = array2 as? [Double] {

    var difference = Array<Double>(repeating: 0, count: array1.count)
    vDSP_vsubD(array2, 1, array1, 1, &difference, 1, vDSP_Length(array1.count))

    vDSP_vabsD(difference, 1, &difference, 1, vDSP_Length(difference.count))

    return mean(difference as! [T])

  } else {

    return mean(zip(array1, array2).map(-).map(abs))

  }
}

/// Calculates the mean of the difference between two arrays of complex number values.
///
/// - Parameters:
///   - array1: The first array of complex number values.
///   - array2: The second array of complex number values.
/// - Returns: The mean of the array generated by subtracting elements in `array2` from `array1`.
private func differenceMean(_ array1: [DSPComplex], _ array2: [DSPComplex]) -> Float {

  guard array1.count == array2.count else {
    fatalError("Expected array1 and array2 to have the same number of elements.")
  }

  let count = array1.count
  let countu = vDSP_Length(count)

  var array1Split =
    DSPSplitComplex(realp: UnsafeMutablePointer<Float>.allocate(capacity: count),
                    imagp: UnsafeMutablePointer<Float>.allocate(capacity: count))

  vDSP_ctoz(array1, 2, &array1Split, 1, countu)

  var array2Split =
    DSPSplitComplex(realp: UnsafeMutablePointer<Float>.allocate(capacity: count),
                    imagp: UnsafeMutablePointer<Float>.allocate(capacity: count))

  vDSP_ctoz(array2, 2, &array2Split, 1, countu)

  var differenceSplit =
    DSPSplitComplex(realp: UnsafeMutablePointer<Float>.allocate(capacity: count),
                    imagp: UnsafeMutablePointer<Float>.allocate(capacity: count))

  vDSP_zvsub(&array2Split, 1, &array1Split, 1, &differenceSplit, 1, countu)

  var differenceReal = Array<Float>(repeating: 0, count: count)
  vDSP_vabs(differenceSplit.realp, 1, &differenceReal, 1, countu)

  var differenceImag = Array<Float>(repeating: 0, count: count)
  vDSP_vabs(differenceSplit.imagp, 1, &differenceImag, 1, countu)

  return (mean(differenceReal) + mean(differenceImag)) / 2

}

/// Calculates the percent deviation between two arrays of floating point numbers.
///
/// - Parameters:
///   - array1: The first array of floating point values.
///   - array2: The second array of floating point values.
/// - Returns: The percent deviation from `array1` to `array2`.
private func percentDeviation<T:FloatingPoint>(_ array1: [T], _ array2: [T]) -> T {

  guard array1.count == array2.count else {
    fatalError("Expected array1 and array2 to have the same number of elements.")
  }

  if let array1 = array1 as? [Float], let array2 = array2 as? [Float] {

    let count = array1.count
    let countu = vDSP_Length(count)

    var buffer = Array<Float>(repeating: 0, count: count)

    vDSP_vsub(array2, 1, array1, 1, &buffer, 1, countu)
    vDSP_vdiv(array2, 1, buffer, 1, &buffer, 1, countu)

    var oneHundered: Float = 100
    vDSP_vsmul(buffer, 1, &oneHundered, &buffer, 1, countu)

    return mean(buffer as! [T])

  } else if let array1 = array1 as? [Double], let array2 = array2 as? [Double] {

    let count = array1.count
    let countu = vDSP_Length(count)

    var buffer = Array<Double>(repeating: 0, count: count)

    vDSP_vsubD(array2, 1, array1, 1, &buffer, 1, countu)
    vDSP_vdivD(array2, 1, buffer, 1, &buffer, 1, countu)

    var oneHundered: Double = 100
    vDSP_vsmulD(buffer, 1, &oneHundered, &buffer, 1, countu)

    return mean(buffer as! [T])

  } else {

    return mean(zip(zip(array2, array1).map(-), array2).map(/).map({$0 * 100}))

  }

}

/// Calculates the percent deviation between two arrays of complex numbers.
///
/// - Parameters:
///   - array1: The first array of complex values.
///   - array2: The second array of complex values.
/// - Returns: The percent deviation from `array1` to `array2`.
private func percentDeviation(_ array1: [DSPComplex], _ array2: [DSPComplex]) -> Float {

  guard array1.count == array2.count else {
    fatalError("Expected array1 and array2 to have the same number of elements.")
  }

  let count = array1.count
  let countu = vDSP_Length(count)

  var array1Split =
    DSPSplitComplex(realp: UnsafeMutablePointer<Float>.allocate(capacity: count),
                    imagp: UnsafeMutablePointer<Float>.allocate(capacity: count))

  vDSP_ctoz(array1, 2, &array1Split, 1, countu)

  var array2Split =
    DSPSplitComplex(realp: UnsafeMutablePointer<Float>.allocate(capacity: count),
                    imagp: UnsafeMutablePointer<Float>.allocate(capacity: count))

  vDSP_ctoz(array2, 2, &array2Split, 1, countu)

  var divergenceRealBuffer = Array<Float>(repeating: 0, count: count)
  vDSP_vsub(array1Split.realp, 1, array2Split.realp, 1, &divergenceRealBuffer, 1, countu)

  vDSP_vdiv(array2Split.realp, 1, divergenceRealBuffer, 1, &divergenceRealBuffer, 1, countu)

  var oneHundered: Float = 100
  vDSP_vsmul(divergenceRealBuffer, 1, &oneHundered, &divergenceRealBuffer, 1, countu)

  var divergenceReal: Float = 0
  vDSP_sve(divergenceRealBuffer, 1, &divergenceReal, countu)

  divergenceReal /= Float(count)

  var divergenceImagBuffer = Array<Float>(repeating: 0, count: count)
  vDSP_vsub(array1Split.imagp, 1, array2Split.imagp, 1, &divergenceImagBuffer, 1, countu)

  vDSP_vdiv(array2Split.imagp, 1, divergenceImagBuffer, 1, &divergenceImagBuffer, 1, countu)

  vDSP_vsmul(divergenceImagBuffer, 1, &oneHundered, &divergenceImagBuffer, 1, countu)

  for index in divergenceImagBuffer.indices where divergenceImagBuffer[index].isNaN {
    divergenceImagBuffer[index] = 0
  }

  var divergenceImag: Float = 0
  vDSP_sve(divergenceImagBuffer, 1, &divergenceImag, countu)

  divergenceImag /= Float(count)

  return (divergenceReal + divergenceImag) / 2

}

/// Tests that ∀ e ∈ `array`, `block(e) == true`.
///
/// - Parameters:
///   - array: The array of elements to test.
///   - block: The block used to test the elements in `array`.
///   - element: The element of `array` being tested.
/// - Returns: `true` if all elements pass and `false` otherwise.
private func test<T>(array: [T], using block: (_ element: T) -> Bool) -> Bool {
  for value in array {
    guard block(value) else { return false }
  }
  return true
}

/// Tests that ∀ a ∈ `array`,  `test(array: a, using: block) == true`.
///
/// - Parameters:
///   - array: The array of arrays of elements to test.
///   - block: The block used to test the elements in the elements of `array`.
///   - element: The element of an element of `array` being tested.
/// - Returns: `true` if all elements pass and `false` otherwise.
private func test<T>(array: [[T]], using block: (_ element: T) -> Bool) -> Bool {
  for child in array {
    guard test(array: child, using: block) else { return false }
  }
  return true
}

/// Tests that ∀ a ∈ `array`,  `test(array: a, using: block) == true`.
///
/// - Parameters:
///   - array: The array of arrays of arrays of elements to test.
///   - block: The block used to test the elements in the elements of the elements of `array`.
///   - element: The element of an element of an element of `array` being tested.
/// - Returns: `true` if all elements pass and `false` otherwise.
private func test<T>(array: [[[T]]], using block: (_ element: T) -> Bool) -> Bool {
  for child in array {
    guard test(array: child, using: block) else { return false }
  }
  return true
}

/// Tests that ∀ e ∈ `array`, `block(e, value) == true`.
///
/// - Parameters:
///   - array: The array of elements to test.
///   - value: The value passed along with `element` to `block`.
///   - block: The block used to test the elements in `array`.
///   - element: The element of `array` being tested.
/// - Returns: `true` if all elements pass and `false` otherwise.
private func test<T>(array: [T], against value: T,
                     using block: (_ element: T, _ value: T) -> Bool) -> Bool
{
  for actual in array {
    guard block(actual, value) else { return false }
  }
  return true
}

/// Tests that ∀ a ∈ `array`, `test(array: a, against: value, using: block) == true`.
///
/// - Parameters:
///   - array: The array of arrays of elements to test.
///   - value: The value passed along with `element` to `block`.
///   - block: The block used to test the elements in the elements of `array`.
///   - element: The element of an element of `array` being tested.
/// - Returns: `true` if all elements pass and `false` otherwise.
private func test<T>(array: [[T]], against value: T,
                     using block: (_ element: T, _ value: T) -> Bool) -> Bool
{
  for child in array {
    guard test(array: child, against: value, using: block) else { return false }
  }
  return true
}

/// Tests that ∀ a ∈ `array`,  `test(array: a, against: value, using: block) == true`.
///
/// - Parameters:
///   - array: The array of arrays of arrays of elements to test.
///   - value: The value passed along with `element` to `block`.
///   - block: The block used to test the elements in the elements of the elements of `array`.
///   - element: The element of an element of an element of `array` being tested.
/// - Returns: `true` if all elements pass and `false` otherwise.
private func test<T>(array: [[[T]]], against value: T,
                     using block: (_ element: T, _ value: T) -> Bool) -> Bool
{
  for child in array {
    guard test(array: child, against: value, using: block) else { return false }
  }
  return true
}

/// Tests that ∀ (e1, e2) ∈ `zip(array1, array2)`, `block(e1, e2) == true`.
///
/// - Parameters:
///   - array1: The first array of elements to test.
///   - array2: The second array of elements to test.
///   - block: The block used to test the elements in `array1` and `array2`.
///   - element1: The element of `array1` being tested.
///   - element2: The element of `array2` being tested.
/// - Returns: `true` if all element pairs pass and `false` otherwise.
private func test<T>(array array1: [T],
                     against array2: [T],
                     using block: (_ element1: T, _ element2: T) -> Bool) -> Bool
{
  guard array1.count == array2.count else { return false }
  for (element1, element2) in zip(array1, array2) {
    guard block(element1, element2) else { return false }
  }
  return true
}

/// Tests that ∀ (a1, a2) ∈ `zip(array1, array2)`, `test(array: a1, against: a2, using: block)
/// == true`.
///
/// - Parameters:
///   - array1: The first array of elements to test.
///   - array2: The second array of elements to test.
///   - block: The block used to test the elements in the elements of `array1` and `array2`.
///   - element1: The element of an element of `array1` being tested.
///   - element2: The element of an element of `array2` being tested.
/// - Returns: `true` if all element pairs pass and `false` otherwise.
private func test<T>(array array1: [[T]],
                     against array2: [[T]],
                     using block: (_ element1: T, _ element2: T) -> Bool) -> Bool
{
  guard array1.count == array2.count else { return false }
  for (child1, child2) in zip(array1, array2) {
    guard test(array: child1, against: child2, using: block) else { return false }
  }
  return true
}

/// Tests that ∀ (a1, a2) ∈ `zip(array1, array2)`, `test(array: a1, against: a2, using: block)
/// == true`.
///
/// - Parameters:
///   - array1: The first array of elements to test.
///   - array2: The second array of elements to test.
///   - block: The block used to test the elements in the elements of the elements of `array1`
///            and `array2`.
///   - element1: The element of an element of an element of `array1` being tested.
///   - element2: The element of an element of an element of `array2` being tested.
/// - Returns: `true` if all element pairs pass and `false` otherwise.
private func test<T>(array array1: [[[T]]],
                     against array2: [[[T]]],
                     using block: (_ element1: T, _ element2: T) -> Bool) -> Bool
{
  guard array1.count == array2.count else { return false }
  for (child1, child2) in zip(array1, array2) {
    guard test(array: child1, against: child2, using: block) else { return false }
  }
  return true
}


/// Asserts that two two dimensional arrays are equal.
///
/// - Parameters:
///   - array1: A two dimensional array.
///   - array2: Another two dimensional array.
///   - message: An optional description of the failure.
///   - file: The file in which failure occurred. Defaults to the file name of the test case in
///           which this function was called.
///   - line: The line number on which failure occurred. Defaults to the line number on which this
///           function was called.
public func XCTAssertEqual<T:Equatable>(_ array1: [[T]],
                                        _ array2: [[T]],
                                        _ message: @autoclosure () -> String = "",
                                        file: StaticString = #file,
                                        line: UInt = #line)
{

  guard !test(array: array1, against: array2, using: ==) else { return }

  let failureDescription = String(format: _XCTFailureFormat(.equal, 100),
                                  description(of: array1), description(of: array2))

  _XCTPreformattedFailureHandler(_XCTCurrentTestCase(),
                                 true,
                                 file.description,
                                 Int(line),
                                 failureDescription, message())

}

/// Asserts that two three dimensional arrays are equal.
///
/// - Parameters:
///   - array1: A three dimensional array.
///   - array2: Another three dimensional array.
///   - message: An optional description of the failure.
///   - file: The file in which failure occurred. Defaults to the file name of the test case in
///           which this function was called.
///   - line: The line number on which failure occurred. Defaults to the line number on which this
///           function was called.
public func XCTAssertEqual<T:Equatable>(_ array1: [[[T]]],
                                        _ array2: [[[T]]],
                                        _ message: @autoclosure () -> String = "",
                                        file: StaticString = #file,
                                        line: UInt = #line)
{

  guard !test(array: array1, against: array2, using: ==) else { return }

  let failureDescription = String(format: _XCTFailureFormat(.equal, 100),
                                  description(of: array1), description(of: array2))

  _XCTPreformattedFailureHandler(_XCTCurrentTestCase(),
                                 true,
                                 file.description,
                                 Int(line),
                                 failureDescription, message())

}

/// Asserts that two arrays of floating point numbers are equal with a certain accuracy.
///
/// - Parameters:
///   - array1: An array of floating point numbers.
///   - array2: Another array of floating point numbers.
///   - accuracy: Describes the maximum difference between values before considering them unequal.
///   - message: An optional description of the failure.
///   - file: The file in which failure occurred. Defaults to the file name of the test case in
///           which this function was called.
///   - line: The line number on which failure occurred. Defaults to the line number on which this
///           function was called.
public func XCTAssertEqual<T:FloatingPoint>(_ array1: [T],
                                            _ array2: [T],
                                            accuracy: T = 0,
                                            _ message: @autoclosure () -> String = "",
                                            file: StaticString = #file,
                                            line: UInt = #line)
{

  guard !test(array: array1, against: array2, using: {
    !($0.isNaN || $1.isNaN) && abs($0 - $1) <= accuracy
  }) else { return }

  let failureDescription = String(format: _XCTFailureFormat(.equalWithAccuracy, 100),
                                  description(of: array1), description(of: array2), "\(accuracy)")

  _XCTPreformattedFailureHandler(_XCTCurrentTestCase(),
                                 true,
                                 file.description,
                                 Int(line),
                                 failureDescription, message())

}

/// Asserts that two two dimensional arrays of floating point numbers are equal with a certain
/// accuracy.
///
/// - Parameters:
///   - array1: A two dimensional array of floating point numbers.
///   - array2: Another two dimensional array of floating point numbers.
///   - accuracy: Describes the maximum difference between values before considering them unequal.
///   - message: An optional description of the failure.
///   - file: The file in which failure occurred. Defaults to the file name of the test case in
///           which this function was called.
///   - line: The line number on which failure occurred. Defaults to the line number on which this
///           function was called.
public func XCTAssertEqual<T:FloatingPoint>(_ array1: [[T]],
                                            _ array2: [[T]],
                                            accuracy: T = 0,
                                            _ message: @autoclosure () -> String = "",
                                            file: StaticString = #file,
                                            line: UInt = #line)
{

  guard !test(array: array1, against: array2, using: {
    !($0.isNaN || $1.isNaN) && abs($0 - $1) <= accuracy
  }) else { return }

  let failureDescription = String(format: _XCTFailureFormat(.equalWithAccuracy, 100),
                                  description(of: array1), description(of: array2), "\(accuracy)")

  _XCTPreformattedFailureHandler(_XCTCurrentTestCase(),
                                 true,
                                 file.description,
                                 Int(line),
                                 failureDescription, message())

}

/// Asserts that two three dimensional arrays of floating point numbers are equal with a certain
/// accuracy.
///
/// - Parameters:
///   - array1: A three dimensional array of floating point numbers.
///   - array2: Another three dimensional array of floating point numbers.
///   - accuracy: Describes the maximum difference between values before considering them unequal.
///   - message: An optional description of the failure.
///   - file: The file in which failure occurred. Defaults to the file name of the test case in
///           which this function was called.
///   - line: The line number on which failure occurred. Defaults to the line number on which this
///           function was called.
public func XCTAssertEqual<T:FloatingPoint>(_ array1: [[[T]]],
                                            _ array2: [[[T]]],
                                            accuracy: T = 0,
                                            _ message: @autoclosure () -> String = "",
                                            file: StaticString = #file,
                                            line: UInt = #line)
{

  guard !test(array: array1, against: array2, using: {
    !($0.isNaN || $1.isNaN) && abs($0 - $1) <= accuracy
  }) else { return }

  let failureDescription = String(format: _XCTFailureFormat(.equalWithAccuracy, 100),
                                  description(of: array1), description(of: array2), "\(accuracy)")

  _XCTPreformattedFailureHandler(_XCTCurrentTestCase(),
                                 true,
                                 file.description,
                                 Int(line),
                                 failureDescription, message())

}

/// Asserts that two arrays of complex numbers are equal with a certain accuracy.
///
/// - Parameters:
///   - array1: An array of complex numbers.
///   - array2: Another array of complex numbers.
///   - accuracy: Describes the maximum difference between values before considering them unequal.
///   - message: An optional description of the failure.
///   - file: The file in which failure occurred. Defaults to the file name of the test case in
///           which this function was called.
///   - line: The line number on which failure occurred. Defaults to the line number on which this
///           function was called.
public func XCTAssertEqual(_ array1: [DSPComplex],
                           _ array2: [DSPComplex],
                           accuracy: Float = 0,
                           _ message: @autoclosure () -> String = "",
                           file: StaticString = #file,
                           line: UInt = #line)
{

  guard !test(array: array1, against: array2, using: {
    !($0.real.isNaN || $1.real.isNaN || $0.imag.isNaN || $1.imag.isNaN)
      && abs($0.real - $1.real) <= accuracy
      && abs($0.imag - $1.imag) <= accuracy
  }) else { return }

  let failureDescription = String(format: _XCTFailureFormat(.equalWithAccuracy, 100),
                                  description(of: array1), description(of: array2),
                                  accuracy.description)

  _XCTPreformattedFailureHandler(_XCTCurrentTestCase(),
                                 true,
                                 file.description,
                                 Int(line),
                                 failureDescription, message())

}

/// Asserts that two two dimensional arrays of complex numbers are equal with a certain accuracy.
///
/// - Parameters:
///   - array1: A two dimensional array of complex numbers.
///   - array2: Another two dimensional array of complex numbers.
///   - accuracy: Describes the maximum difference between values before considering them unequal.
///   - message: An optional description of the failure.
///   - file: The file in which failure occurred. Defaults to the file name of the test case in
///           which this function was called.
///   - line: The line number on which failure occurred. Defaults to the line number on which this
///           function was called.
public func XCTAssertEqual(_ array1: [[DSPComplex]],
                           _ array2: [[DSPComplex]],
                           accuracy: Float = 0,
                           _ message: @autoclosure () -> String = "",
                           file: StaticString = #file,
                           line: UInt = #line)
{

  guard !test(array: array1, against: array2, using: {
    !($0.real.isNaN || $1.real.isNaN || $0.imag.isNaN || $1.imag.isNaN)
      && abs($0.real - $1.real) <= accuracy
      && abs($0.imag - $1.imag) <= accuracy
  }) else { return }

  let failureDescription = String(format: _XCTFailureFormat(.equalWithAccuracy, 100),
                                  description(of: array1), description(of: array2),
                                  accuracy.description)

  _XCTPreformattedFailureHandler(_XCTCurrentTestCase(),
                                 true,
                                 file.description,
                                 Int(line),
                                 failureDescription, message())

}

/// Asserts that two three dimensional arrays of complex numbers are equal with a certain accuracy.
///
/// - Parameters:
///   - array1: A three dimensional array of complex numbers.
///   - array2: Another three dimensional array of complex numbers.
///   - accuracy: Describes the maximum difference between values before considering them unequal.
///   - message: An optional description of the failure.
///   - file: The file in which failure occurred. Defaults to the file name of the test case in
///           which this function was called.
///   - line: The line number on which failure occurred. Defaults to the line number on which this
///           function was called.
public func XCTAssertEqual(_ array1: [[[DSPComplex]]],
                           _ array2: [[[DSPComplex]]],
                           accuracy: Float = 0,
                           _ message: @autoclosure () -> String = "",
                           file: StaticString = #file,
                           line: UInt = #line)
{

  guard !test(array: array1, against: array2, using: {
    !($0.real.isNaN || $1.real.isNaN || $0.imag.isNaN || $1.imag.isNaN)
      && abs($0.real - $1.real) <= accuracy
      && abs($0.imag - $1.imag) <= accuracy
  }) else { return }

  let failureDescription = String(format: _XCTFailureFormat(.equalWithAccuracy, 100),
                                  description(of: array1), description(of: array2),
                                  accuracy.description)

  _XCTPreformattedFailureHandler(_XCTCurrentTestCase(),
                                 true,
                                 file.description,
                                 Int(line),
                                 failureDescription, message())

}

/// Asserts that two arrays of floating point numbers are equal with a certain accuracy.
///
/// - Parameters:
///   - array1: An array of floating point numbers.
///   - array2: Another array of floating point numbers.
///   - deviation: Describes the maximum deviation between values before considering them unequal.
///   - message: An optional description of the failure.
///   - file: The file in which failure occurred. Defaults to the file name of the test case in
///           which this function was called.
///   - line: The line number on which failure occurred. Defaults to the line number on which this
///           function was called.
public func XCTAssertEqual<T:FloatingPoint>(_ array1: [T],
                                            _ array2: [T],
                                            deviation: T = 0,
                                            _ message: @autoclosure () -> String = "",
                                            file: StaticString = #file,
                                            line: UInt = #line)
{

  guard !test(array: array1, against: array2, using: {
    equal($0, $1, deviation: deviation)
  }) else { return }

  let failureDescription = """
    XCTAssertEqual failed: ("\(description(of: array1))") is not equal to \
    ("\(description(of: array2))") with deviation  ("\(deviation)")
    """

  _XCTPreformattedFailureHandler(_XCTCurrentTestCase(),
                                 true,
                                 file.description,
                                 Int(line),
                                 failureDescription, message())

}

/// Asserts that two two dimensional arrays of floating point numbers are equal with a certain
/// accuracy.
///
/// - Parameters:
///   - array1: A two dimensional array of floating point numbers.
///   - array2: Another two dimensional array of floating point numbers.
///   - deviation: Describes the maximum deviation between values before considering them unequal.
///   - message: An optional description of the failure.
///   - file: The file in which failure occurred. Defaults to the file name of the test case in
///           which this function was called.
///   - line: The line number on which failure occurred. Defaults to the line number on which this
///           function was called.
public func XCTAssertEqual<T:FloatingPoint>(_ array1: [[T]],
                                            _ array2: [[T]],
                                            deviation: T = 0,
                                            _ message: @autoclosure () -> String = "",
                                            file: StaticString = #file,
                                            line: UInt = #line)
{

  guard !test(array: array1, against: array2, using: {
    equal($0, $1, deviation: deviation)
  }) else { return }

  let failureDescription = """
    XCTAssertEqual failed: ("\(description(of: array1))") is not equal to \
    ("\(description(of: array2))") with deviation  ("\(deviation)")
    """

  _XCTPreformattedFailureHandler(_XCTCurrentTestCase(),
                                 true,
                                 file.description,
                                 Int(line),
                                 failureDescription, message())

}

/// Asserts that two three dimensional arrays of floating point numbers are equal with a certain
/// accuracy.
///
/// - Parameters:
///   - array1: A three dimensional array of floating point numbers.
///   - array2: Another three dimensional array of floating point numbers.
///   - deviation: Describes the maximum deviation between values before considering them unequal.
///   - message: An optional description of the failure.
///   - file: The file in which failure occurred. Defaults to the file name of the test case in
///           which this function was called.
///   - line: The line number on which failure occurred. Defaults to the line number on which this
///           function was called.
public func XCTAssertEqual<T:FloatingPoint>(_ array1: [[[T]]],
                                            _ array2: [[[T]]],
                                            deviation: T = 0,
                                            _ message: @autoclosure () -> String = "",
                                            file: StaticString = #file,
                                            line: UInt = #line)
{

  guard !test(array: array1, against: array2, using: {
    equal($0, $1, deviation: deviation)
  }) else { return }

  let failureDescription = """
    XCTAssertEqual failed: ("\(description(of: array1))") is not equal to \
    ("\(description(of: array2))") with deviation  ("\(deviation)")
    """

  _XCTPreformattedFailureHandler(_XCTCurrentTestCase(),
                                 true,
                                 file.description,
                                 Int(line),
                                 failureDescription, message())

}

/// Asserts that two arrays of complex numbers are equal with a certain accuracy.
///
/// - Parameters:
///   - array1: An array of complex numbers.
///   - array2: Another array of complex numbers.
///   - deviation: Describes the maximum deviation between values before considering them unequal.
///   - message: An optional description of the failure.
///   - file: The file in which failure occurred. Defaults to the file name of the test case in
///           which this function was called.
///   - line: The line number on which failure occurred. Defaults to the line number on which this
///           function was called.
public func XCTAssertEqual(_ array1: [DSPComplex],
                           _ array2: [DSPComplex],
                           deviation: Float = 0,
                           _ message: @autoclosure () -> String = "",
                           file: StaticString = #file,
                           line: UInt = #line)
{

  guard !test(array: array1, against: array2, using: {
    equal($0.real, $1.real, deviation: deviation) && equal($0.imag, $1.imag, deviation: deviation)
  }) else { return }

  let failureDescription = """
    XCTAssertEqual failed: ("\(description(of: array1))") is not equal to \
    ("\(description(of: array2))") with deviation  ("\(deviation)")
    """

  _XCTPreformattedFailureHandler(_XCTCurrentTestCase(),
                                 true,
                                 file.description,
                                 Int(line),
                                 failureDescription, message())

}

/// Asserts that two two dimensional arrays of complex numbers are equal with a certain accuracy.
///
/// - Parameters:
///   - array1: A two dimensional array of complex numbers.
///   - array2: Another two dimensional array of complex numbers.
///   - deviation: Describes the maximum deviation between values before considering them unequal.
///   - message: An optional description of the failure.
///   - file: The file in which failure occurred. Defaults to the file name of the test case in
///           which this function was called.
///   - line: The line number on which failure occurred. Defaults to the line number on which this
///           function was called.
public func XCTAssertEqual(_ array1: [[DSPComplex]],
                           _ array2: [[DSPComplex]],
                           deviation: Float = 0,
                           _ message: @autoclosure () -> String = "",
                           file: StaticString = #file,
                           line: UInt = #line)
{

  guard !test(array: array1, against: array2, using: {
    equal($0.real, $1.real, deviation: deviation) && equal($0.imag, $1.imag, deviation: deviation)
  }) else { return }

  let failureDescription = """
    XCTAssertEqual failed: ("\(description(of: array1))") is not equal to \
    ("\(description(of: array2))") with deviation  ("\(deviation)")
    """

  _XCTPreformattedFailureHandler(_XCTCurrentTestCase(),
                                 true,
                                 file.description,
                                 Int(line),
                                 failureDescription, message())

}

/// Asserts that two three dimensional arrays of complex numbers are equal with a certain accuracy.
///
/// - Parameters:
///   - array1: A three dimensional array of complex numbers.
///   - array2: Another three dimensional array of complex numbers.
///   - deviation: Describes the maximum deviation between values before considering them unequal.
///   - message: An optional description of the failure.
///   - file: The file in which failure occurred. Defaults to the file name of the test case in
///           which this function was called.
///   - line: The line number on which failure occurred. Defaults to the line number on which this
///           function was called.
public func XCTAssertEqual(_ array1: [[[DSPComplex]]],
                           _ array2: [[[DSPComplex]]],
                           deviation: Float = 0,
                           _ message: @autoclosure () -> String = "",
                           file: StaticString = #file,
                           line: UInt = #line)
{

  guard !test(array: array1, against: array2, using: {
    equal($0.real, $1.real, deviation: deviation) && equal($0.imag, $1.imag, deviation: deviation)
  }) else { return }

  let failureDescription = """
    XCTAssertEqual failed: ("\(description(of: array1))") is not equal to \
    ("\(description(of: array2))") with deviation  ("\(deviation)")
    """

  _XCTPreformattedFailureHandler(_XCTCurrentTestCase(),
                                 true,
                                 file.description,
                                 Int(line),
                                 failureDescription, message())

}

/// Asserts that an array of floating point numbers contains no `nan` or `inf`
/// values.
///
/// - Parameters:
///   - array: An array of floating point numbers.
///   - message: An optional description of the failure.
///   - file: The file in which failure occurred. Defaults to the file name of the test case in
///           which this function was called.
///   - line: The line number on which failure occurred. Defaults to the line number on which this
///           function was called.
public func XCTAssertNotNaNOrInf<T:FloatingPoint>(_ array: [T],
                                                  _ message: @autoclosure () -> String = "",
                                                  file: StaticString = #file,
                                                  line: UInt = #line)
{

  guard !test(array: array, using: {!($0.isNaN || $0.isInfinite)}) else  { return }

  let failureDescription = """
    XCTAssertNotNaNOrInf failed: ("\(description(of: array))") contains at least one \
    'nan' or 'inf' value.
    """

  _XCTPreformattedFailureHandler(_XCTCurrentTestCase(),
                                 true,
                                 file.description,
                                 Int(line),
                                 failureDescription, message())

}
/// Asserts that a two dimensional array of floating point numbers contains no `nan` or `inf`
/// values.
///
/// - Parameters:
///   - array: A two dimensional array of floating point numbers.
///   - message: An optional description of the failure.
///   - file: The file in which failure occurred. Defaults to the file name of the test case in
///           which this function was called.
///   - line: The line number on which failure occurred. Defaults to the line number on which this
///           function was called.
public func XCTAssertNotNaNOrInf<T:FloatingPoint>(_ array: [[T]],
                                                  _ message: @autoclosure () -> String = "",
                                                  file: StaticString = #file,
                                                  line: UInt = #line)
{

  guard !test(array: array, using: {!($0.isNaN || $0.isInfinite)}) else  { return }

  let failureDescription = """
    XCTAssertNotNaNOrInf failed: ("\(description(of: array))") contains at least one \
    'nan' or 'inf' value.
    """

  _XCTPreformattedFailureHandler(_XCTCurrentTestCase(),
                                 true,
                                 file.description,
                                 Int(line),
                                 failureDescription, message())

}

/// Asserts that a three dimensional array of floating point numbers contains no `nan` or `inf`
/// values.
///
/// - Parameters:
///   - array: A three dimensional array of floating point numbers.
///   - message: An optional description of the failure.
///   - file: The file in which failure occurred. Defaults to the file name of the test case in
///           which this function was called.
///   - line: The line number on which failure occurred. Defaults to the line number on which this
///           function was called.
public func XCTAssertNotNaNOrInf<T:FloatingPoint>(_ array: [[[T]]],
                                                  _ message: @autoclosure () -> String = "",
                                                  file: StaticString = #file,
                                                  line: UInt = #line)
{

  guard !test(array: array, using: {!($0.isNaN || $0.isInfinite)}) else  { return }

  let failureDescription = """
    XCTAssertNotNaNOrInf failed: ("\(description(of: array))") contains at least one \
    'nan' or 'inf' value.
    """

  _XCTPreformattedFailureHandler(_XCTCurrentTestCase(),
                                 true,
                                 file.description,
                                 Int(line),
                                 failureDescription, message())

}

/// Asserts that an array of floating point numbers contains no values less than a given value.
///
/// - Parameters:
///   - array: An array of floating point numbers.
///   - value: The value to which all values in `array` must be greater than or equal.
///   - message: An optional description of the failure.
///   - file: The file in which failure occurred. Defaults to the file name of the test case in
///           which this function was called.
///   - line: The line number on which failure occurred. Defaults to the line number on which this
///           function was called.
public func XCTAssertGreaterThanOrEqual<T:FloatingPoint>(_ array: [T],
                                                         _ value: T,
                                                         _ message: @autoclosure () -> String = "",
                                                         file: StaticString = #file,
                                                         line: UInt = #line)
{

  guard !test(array: array, against: value, using: >=) else  { return }

  let failureDescription = """
    XCTAssertGreaterThanOrEqual failed: ("\(description(of: array))") contains at least one \
    value < ("\(value)").
    """

  _XCTPreformattedFailureHandler(_XCTCurrentTestCase(),
                                 true,
                                 file.description,
                                 Int(line),
                                 failureDescription, message())

}
/// Asserts that a two dimensional array of floating point numbers contains values greater than
/// or equal to a given value.
///
/// - Parameters:
///   - array: A two dimensional array of floating point numbers.
///   - value: The value to which all values in `array` must be greater than or equal.
///   - message: An optional description of the failure.
///   - file: The file in which failure occurred. Defaults to the file name of the test case in
///           which this function was called.
///   - line: The line number on which failure occurred. Defaults to the line number on which this
///           function was called.
public func XCTAssertGreaterThanOrEqual<T:FloatingPoint>(_ array: [[T]],
                                                         _ value: T,
                                                         _ message: @autoclosure () -> String = "",
                                                         file: StaticString = #file,
                                                         line: UInt = #line)
{

  guard !test(array: array, against: value, using: >=) else { return }

  let failureDescription = """
    XCTAssertGreaterThanOrEqual failed: ("\(description(of: array))") contains at least one \
    value < ("\(value)").
    """

  _XCTPreformattedFailureHandler(_XCTCurrentTestCase(),
                                 true,
                                 file.description,
                                 Int(line),
                                 failureDescription, message())

}

/// Asserts that a three dimensional array of floating point numbers contains values greater than
/// or equal to a given value.
///
/// - Parameters:
///   - array: A three dimensional array of floating point numbers.
///   - value: The value to which all values in `array` must be greater than or equal.
///   - message: An optional description of the failure.
///   - file: The file in which failure occurred. Defaults to the file name of the test case in
///           which this function was called.
///   - line: The line number on which failure occurred. Defaults to the line number on which this
///           function was called.
public func XCTAssertGreaterThanOrEqual<T:FloatingPoint>(_ array: [[[T]]],
                                                         _ value: T,
                                                         _ message: @autoclosure () -> String = "",
                                                         file: StaticString = #file,
                                                         line: UInt = #line)
{

  guard !test(array: array, against: value, using: >=) else { return }

  let failureDescription = """
    XCTAssertGreaterThanOrEqual failed: ("\(description(of: array))") contains at least one \
    value < ("\(value)").
    """

  _XCTPreformattedFailureHandler(_XCTCurrentTestCase(),
                                 true,
                                 file.description,
                                 Int(line),
                                 failureDescription, message())

}


/// Asserts that the average of the floating point numbers in an array is equal to an expected
/// value with a certain accuracy.
///
/// - Parameters:
///   - array: An array of floating point numbers.
///   - expected: The expected average for the values in `array`.
///   - accuracy: Describes the maximum difference between the average of `array` and `expected`.
///   - message: An optional description of the failure.
///   - file: The file in which failure occurred. Defaults to the file name of the test case in
///           which this function was called.
///   - line: The line number on which failure occurred. Defaults to the line number on which this
///           function was called.
public func XCTAssertAverageEqual<T:FloatingPoint>(_ array: [T],
                                                   _ expected: T,
                                                   accuracy: T = 0,
                                                   _ message: @autoclosure () -> String = "",
                                                   file: StaticString = #file,
                                                   line: UInt = #line)
{

//  let average = array.reduce(0, +) / T(array.count)

  let average = mean(array)

  guard abs(average - expected) > accuracy else  { return }

  let failureDescription = """
    XCTAssertAverageEqual failed: ("\(average)") is not equal to ("\(expected)") \
    +/- ("\(accuracy)")
    """

  _XCTPreformattedFailureHandler(_XCTCurrentTestCase(),
                                 true,
                                 file.description,
                                 Int(line),
                                 failureDescription, message())

}

/// Asserts that the average of the floating point numbers in an array is equal to an expected
/// value with a certain accuracy.
///
/// - Parameters:
///   - array: An array of floating point numbers.
///   - expected: The expected average for the values in `array`.
///   - deviation: Describes the maximum deviation between the average of `array` and `expected`.
///   - message: An optional description of the failure.
///   - file: The file in which failure occurred. Defaults to the file name of the test case in
///           which this function was called.
///   - line: The line number on which failure occurred. Defaults to the line number on which this
///           function was called.
public func XCTAssertAverageEqual<T:FloatingPoint>(_ array: [T],
                                                   _ expected: T,
                                                   deviation: T = 0,
                                                   _ message: @autoclosure () -> String = "",
                                                   file: StaticString = #file,
                                                   line: UInt = #line)
{

//  let average = array.reduce(0, +) / T(array.count)

  let average = mean(array)

  guard !equal(average, expected, deviation: deviation) else  { return }

  let failureDescription = """
    XCTAssertAverageEqual failed: ("\(average)") is not equal to ("\(expected)") \
    with deviation ("\(deviation)")
    """

  _XCTPreformattedFailureHandler(_XCTCurrentTestCase(),
                                 true,
                                 file.description,
                                 Int(line),
                                 failureDescription, message())

}

/// Asserts that the mean of the difference between two arrays of floating point numbers is
/// less than a given value.
///
/// - Parameters:
///   - array1: The first array of floating point numbers.
///   - array2: The second array of floating point numbers.
///   - mean: The value below which the difference mean of `array1` and `array2` must lie.
///   - accuracy: The allowable difference between the calculated mean and `mean`.
///   - message: An optional description of the failure.
///   - file: The file in which failure occurred. Defaults to the file name of the test case in
///           which this function was called.
///   - line: The line number on which failure occurred. Defaults to the line number on which this
///           function was called.
public func XCTAssertDifferenceMeanLessThan<T>(_ array1: [T],
                                               _ array2: [T],
                                               _ mean: T,
                                               accuracy: T = 0,
                                               _ message: @autoclosure () -> String = "",
                                               file: StaticString = #file,
                                               line: UInt = #line)
  where T:FloatingPoint
{
  let calculatedMean = differenceMean(array1, array2)

  guard calculatedMean >= mean else  { return }

  guard abs(calculatedMean - mean) > accuracy else { return }

  let failureDescription = """
  XCTAssertDifferenceMeanLessThan failed: ("\(calculatedMean)") is not less than ("\(mean)") \
  +/- ("\(accuracy)")"
  """

  _XCTPreformattedFailureHandler(_XCTCurrentTestCase(),
                                 true,
                                 file.description,
                                 Int(line),
                                 failureDescription, message())

}

/// Asserts that the mean of the difference between two arrays of floating point numbers is
/// less than or equal to a given value.
///
/// - Parameters:
///   - array1: The first array of floating point numbers.
///   - array2: The second array of floating point numbers.
///   - mean: The value that the difference mean of `array1` and `array2` must not be above.
///   - accuracy: The allowable difference between the calculated mean and `mean`.
///   - message: An optional description of the failure.
///   - file: The file in which failure occurred. Defaults to the file name of the test case in
///           which this function was called.
///   - line: The line number on which failure occurred. Defaults to the line number on which this
///           function was called.
public func XCTAssertDifferenceMeanLessThanOrEqual<T>(_ array1: [T],
                                                      _ array2: [T],
                                                      _ mean: T,
                                                      accuracy: T = 0,
                                                      _ message: @autoclosure () -> String = "",
                                                      file: StaticString = #file,
                                                      line: UInt = #line)
  where T:FloatingPoint
{
  let calculatedMean = differenceMean(array1, array2)

  guard calculatedMean > mean else  { return }

  guard abs(calculatedMean - mean) > accuracy else { return }

  let failureDescription = """
  XCTAssertDifferenceMeanLessThanOrEqual failed: ("\(calculatedMean)") is not less than or equal \
  to ("\(mean)") +/- ("\(accuracy)")"
  """

  _XCTPreformattedFailureHandler(_XCTCurrentTestCase(),
                                 true,
                                 file.description,
                                 Int(line),
                                 failureDescription, message())

}

/// Asserts that the mean of the difference between two arrays of complex numbers is
/// less than a given value.
///
/// - Parameters:
///   - array1: The first array of complex numbers.
///   - array2: The second array of complex numbers.
///   - mean: The value below which the difference mean of `array1` and `array2` must lie.
///   - accuracy: The allowable difference between the calculated mean and `mean`.
///   - message: An optional description of the failure.
///   - file: The file in which failure occurred. Defaults to the file name of the test case in
///           which this function was called.
///   - line: The line number on which failure occurred. Defaults to the line number on which this
///           function was called.
public func XCTAssertDifferenceMeanLessThan(_ array1: [DSPComplex],
                                            _ array2: [DSPComplex],
                                            _ mean: Float,
                                            accuracy: Float = 0,
                                            _ message: @autoclosure () -> String = "",
                                            file: StaticString = #file,
                                            line: UInt = #line)
{
  let calculatedMean = differenceMean(array1, array2)

  guard calculatedMean >= mean else  { return }

  guard abs(calculatedMean - mean) > accuracy else { return }

  let failureDescription = """
  XCTAssertDifferenceMeanLessThan failed: ("\(calculatedMean)") is not less than ("\(mean)") \
  +/- ("\(accuracy)")
  """

  _XCTPreformattedFailureHandler(_XCTCurrentTestCase(),
                                 true,
                                 file.description,
                                 Int(line),
                                 failureDescription, message())

}

/// Asserts that the mean of the difference between two arrays of complex numbers is
/// less than or equal to a given value.
///
/// - Parameters:
///   - array1: The first array of complex numbers.
///   - array2: The second array of complex numbers.
///   - mean: The value that the difference mean of `array1` and `array2` must not be above.
///   - accuracy: The allowable difference between the calculated mean and `mean`.
///   - message: An optional description of the failure.
///   - file: The file in which failure occurred. Defaults to the file name of the test case in
///           which this function was called.
///   - line: The line number on which failure occurred. Defaults to the line number on which this
///           function was called.
public func XCTAssertDifferenceMeanLessThanOrEqual(_ array1: [DSPComplex],
                                                   _ array2: [DSPComplex],
                                                   _ mean: Float,
                                                   accuracy: Float = 0,
                                                   _ message: @autoclosure () -> String = "",
                                                   file: StaticString = #file,
                                                   line: UInt = #line)
{
  let calculatedMean = differenceMean(array1, array2)

  guard calculatedMean > mean else  { return }

  guard abs(calculatedMean - mean) > accuracy else { return }

  let failureDescription = """
  XCTAssertDifferenceMeanLessThanOrEqual failed: ("\(calculatedMean)") is not less than or \
  equal to ("\(mean)") +/- ("\(accuracy)")
  """

  _XCTPreformattedFailureHandler(_XCTCurrentTestCase(),
                                 true,
                                 file.description,
                                 Int(line),
                                 failureDescription, message())

}

/// Asserts that the percent deviation between two arrays of floating point numbers is
/// less than a given value.
///
/// - Parameters:
///   - array1: The first array of floating point numbers.
///   - array2: The second array of floating point numbers.
///   - deviation: The value below which the deviation of `array1` from `array2` must lie.
///   - accuracy: The allowable difference between the calculated deviaton and `deviation`.
///   - message: An optional description of the failure.
///   - file: The file in which failure occurred. Defaults to the file name of the test case in
///           which this function was called.
///   - line: The line number on which failure occurred. Defaults to the line number on which this
///           function was called.
public func XCTAssertPercentDeviationLessThan<T>(_ array1: [T],
                                                 _ array2: [T],
                                                 _ deviation: T,
                                                 accuracy: T = 0,
                                                 _ message: @autoclosure () -> String = "",
                                                 file: StaticString = #file,
                                                 line: UInt = #line)
  where T:FloatingPoint
{

  let calculatedPercentDeviation = percentDeviation(array1, array2)

  guard calculatedPercentDeviation >= deviation else { return }

  guard abs(calculatedPercentDeviation - deviation) > accuracy else { return }

  let failureDescription = """
  XCTAssertPercentDeviationLessThan failed: ("\(calculatedPercentDeviation)") is not less than \
  ("\(deviation)") +/- ("\(accuracy)")
  """

  _XCTPreformattedFailureHandler(_XCTCurrentTestCase(),
                                 true,
                                 file.description,
                                 Int(line),
                                 failureDescription, message())

}

/// Asserts that the percent deviation between two arrays of floating point numbers is
/// less than or equal to a given value.
///
/// - Parameters:
///   - array1: The first array of floating point numbers.
///   - array2: The second array of floating point numbers.
///   - deviation: The value which the deviation of `array1` from `array2` must not be above.
///   - accuracy: The allowable difference between the calculated deviaton and `deviation`.
///   - message: An optional description of the failure.
///   - file: The file in which failure occurred. Defaults to the file name of the test case in
///           which this function was called.
///   - line: The line number on which failure occurred. Defaults to the line number on which this
///           function was called.
public func XCTAssertPercentDeviationLessThanOrEqual<T>(_ array1: [T],
                                                        _ array2: [T],
                                                        _ deviation: T,
                                                        accuracy: T = 0,
                                                        _ message: @autoclosure () -> String = "",
                                                        file: StaticString = #file,
                                                        line: UInt = #line)
  where T:FloatingPoint
{

  let calculatedPercentDeviation = percentDeviation(array1, array2)

  guard calculatedPercentDeviation > deviation else { return }

  guard abs(calculatedPercentDeviation - deviation) > accuracy else { return }

  let failureDescription = """
  XCTAssertPercentDeviationLessThanOrEqual failed: ("\(calculatedPercentDeviation)") is not less
  than or equal to ("\(deviation)") +/- ("\(accuracy)")
  """

  _XCTPreformattedFailureHandler(_XCTCurrentTestCase(),
                                 true,
                                 file.description,
                                 Int(line),
                                 failureDescription, message())

}

/// Asserts that the percent deviation between two arrays of complex numbers is less than a
/// given value.
///
/// - Parameters:
///   - array1: The first array of complex numbers.
///   - array2: The second array of complex numbers.
///   - deviation: The value below which the deviation of `array1` from `array2` must lie.
///   - accuracy: The allowable difference between the calculated deviaton and `deviation`.
///   - message: An optional description of the failure.
///   - file: The file in which failure occurred. Defaults to the file name of the test case in
///           which this function was called.
///   - line: The line number on which failure occurred. Defaults to the line number on which this
///           function was called.
public func XCTAssertPercentDeviationLessThan(_ array1: [DSPComplex],
                                              _ array2: [DSPComplex],
                                              _ deviation: Float,
                                              accuracy: Float = 0,
                                              _ message: @autoclosure () -> String = "",
                                              file: StaticString = #file,
                                              line: UInt = #line)
{

  let calculatedPercentDeviation = percentDeviation(array1, array2)

  guard calculatedPercentDeviation >= deviation else { return }

  guard abs(calculatedPercentDeviation - deviation) > accuracy else { return }

  let failureDescription = """
  XCTAssertPercentDeviationLessThan failed: ("\(calculatedPercentDeviation)") is not less than \
  ("\(deviation)") +/- ("\(accuracy)")
  """

  _XCTPreformattedFailureHandler(_XCTCurrentTestCase(),
                                 true,
                                 file.description,
                                 Int(line),
                                 failureDescription, message())

}

/// Asserts that the percent deviation between two arrays of complex numbers is less than or equal
/// to a given value.
///
/// - Parameters:
///   - array1: The first array of complex numbers.
///   - array2: The second array of complex numbers.
///   - deviation: The value which the deviation of `array1` from `array2` must not be above.
///   - accuracy: The allowable difference between the calculated deviaton and `deviation`.
///   - message: An optional description of the failure.
///   - file: The file in which failure occurred. Defaults to the file name of the test case in
///           which this function was called.
///   - line: The line number on which failure occurred. Defaults to the line number on which this
///           function was called.
public func XCTAssertPercentDeviationLessThanOrEqual(_ array1: [DSPComplex],
                                                     _ array2: [DSPComplex],
                                                     _ deviation: Float,
                                                     accuracy: Float = 0,
                                                     _ message: @autoclosure () -> String = "",
                                                     file: StaticString = #file,
                                                     line: UInt = #line)
{

  let calculatedPercentDeviation = percentDeviation(array1, array2)

  guard calculatedPercentDeviation > deviation else { return }

  guard abs(calculatedPercentDeviation - deviation) > accuracy else { return }

  let failureDescription = """
  XCTAssertPercentDeviationLessThanOrEqual failed: ("\(calculatedPercentDeviation)") is not less
  than or equal to ("\(deviation)") +/- ("\(accuracy)")
  """

  _XCTPreformattedFailureHandler(_XCTCurrentTestCase(),
                                 true,
                                 file.description,
                                 Int(line),
                                 failureDescription, message())

}
